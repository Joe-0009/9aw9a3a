#include "../minishell.h"

static void	expand_and_strip_arg(t_expand_vars *v)
{
	char	*expanded;
	char	*stripped;

	if (!v->cmd->args[v->i])
		return ;
	expanded = expand_variables(v->cmd->args[v->i], v->envp);
	safe_free((void **)&v->cmd->args[v->i]);
	if (!expanded)
	{
		v->cmd->args[i] = NULL;
		return ;
	}
	v->cmd->args[v->i] = expanded;
	stripped = strip_quotes(v->cmd->args[v->i]);
	if (stripped)
	{
		safe_free((void **)&v->cmd->args[v->i]);
		v->cmd->args[v->i] = stripped;
	}
}

static void	process_arg_expansion(t_expand_vars *v)
{
	char	*stripped;

	v->was_arg_quoted = was_quoted(v->cmd->args[v->i]);
	v->had_quoted_vars = has_var_in_dquotes(v->cmd->args[v->i]);
	if (!is_var_in_squotes(v->cmd->args[v->i]))
		expand_and_strip_arg(v);
	else
	{
		stripped = strip_quotes(v->cmd->args[v->i]);
		if (stripped)
		{
			safe_free((void **)&v->cmd->args[v->i]);
			v->cmd->args[v->i] = stripped;
		}
	}
}

void	expand_args_loop(t_expand_vars *v)
{
	if (!v->cmd || !v->cmd->args || v->cmd->args_count <= 0)
		return ;
	v->i = 0;
	while (v->i < v->cmd->args_count)
	{
		if (!v->cmd->args[v->i])
		{
			v->i++;
			continue ;
		}
		process_arg_expansion(v);
		if (v->i > 0 || v->cmd->args_count == 1)
		{
			if (!v->was_arg_quoted && !v->had_quoted_vars)
			{
				v->added = split_and_insert_args(v);
				if (v->added > 0)
					v->i += v->added - 1;
			}
		}
		v->i++;
	}
}

void	expand_redirections_loop(t_expand_vars *v)
{
	t_redirections	*redir;
	char			*expanded;

	redir = v->cmd->redirections;
	while (redir)
	{
		if (redir->type != TOKEN_HEREDOC && !redir->was_in_squotes)
		{
			expanded = expand_variables(redir->file, v->envp);
			if (expanded)
			{
				safe_free((void **)&redir->file);
				redir->file = expanded;
			}
		}
		redir = redir->next;
	}
}
#include "../minishell.h"

void	copy_and_replace_args(t_command *cmd, char **new_args, int pos,
		char **split_words)
{
	int	i;
	int	j;
	int	k;
	int	l;

	i = -1;
	while (++i < pos)
		new_args[i] = cmd->args[i];
	j = -1;
	while (split_words[++j])
		new_args[i + j] = ft_strdup(split_words[j]);
	k = pos + 1;
	while (k < cmd->args_count)
	{
		new_args[i + j] = cmd->args[k];
		k++;
		j++;
	}
	new_args[i + j] = NULL;
	safe_free((void **)&cmd->args[pos]);
	l = -1;
	while (split_words[++l])
		safe_free((void **)&split_words[l]);
	safe_free((void **)&split_words);
}

int	add_split_args_to_command(t_command *cmd, int pos, char **split_words)
{
	int		word_count;
	char	**new_args;
	int		new_size;

	word_count = count_split_words(split_words);
	if (word_count == 0)
		return (0);
	new_size = cmd->args_count + word_count - 1;
	new_args = ft_calloc(new_size + 1, sizeof(char *));
	if (!new_args)
		return (0);
	copy_and_replace_args(cmd, new_args, pos, split_words);
	safe_free((void **)&cmd->args);
	cmd->args = new_args;
	cmd->args_count = new_size;
	return (word_count);
}

static void	free_split_words(char **split_words)
{
	int	i;

	i = 0;
	while (split_words[i])
	{
		safe_free((void **)&split_words[i]);
		i++;
	}
	safe_free((void **)&split_words);
}

int	split_and_insert_args(t_expand_vars *v)
{
	char	**split_words;
	int		added;

	if ((v->i > 0 && !v->is_export) || (v->i == 0 && v->cmd->args_count == 1))
	{
		split_words = ft_split(v->cmd->args[v->i], ' ');
		if (split_words && split_words[0])
		{
			if (count_split_words(split_words) > 1 || v->i > 0)
			{
				added = add_split_args_to_command(v->cmd, v->i, split_words);
				if (added > 0)
					return (added);
			}
			else
				free_split_words(split_words);
		}
		else if (split_words)
			free_split_words(split_words);
	}
	return (0);
}

void	compact_args(t_command *cmd, int *i, int *j)
{
	int	k;

	k = *i + 1;
	while (k < cmd->args_count)
	{
		if (cmd->args[k])
		{
			cmd->args[*j] = cmd->args[k];
			*j = *j + 1;
		}
		k++;
	}
	cmd->args[*j] = NULL;
	cmd->args_count = *j;
}
#include "../minishell.h"


void	expand_command_args(t_command *cmd, char **envp)
{
	t_expand_vars	v;

	v.cmd = cmd;
	v.envp = envp;
	v.i = 0;
	v.j = 0;
	v.added = 0;
	if (cmd && cmd->args && cmd->args_count > 0)
	{
		v.is_export = (cmd->args[0] && ft_strcmp(cmd->args[0], "export") == 0);
		expand_args_loop(&v);
	}
	if (cmd)
	{
		expand_redirections_loop(&v);
		clean_empty_args(cmd);
	}
}
#include "../minishell.h"

void	update_quote_state(char c, t_state *state)
{
	if (c == '"' && *state != STATE_IN_SINGLE_QUOTE)
	{
		if (*state == STATE_NORMAL)
			*state = STATE_IN_DOUBLE_QUOTE;
		else
			*state = STATE_NORMAL;
	}
	else if (c == '\'' && *state != STATE_IN_DOUBLE_QUOTE)
	{
		if (*state == STATE_NORMAL)
			*state = STATE_IN_SINGLE_QUOTE;
		else
			*state = STATE_NORMAL;
	}
}

int	is_var_in_squotes(const char *str)
{
	int		i;
	t_state	state;

	i = 0;
	state = STATE_NORMAL;
	while (str[i])
	{
		update_quote_state(str[i], &state);
		if (str[i] == '$' && state == STATE_IN_SINGLE_QUOTE)
			return (1);
		i++;
	}
	return (0);
}

int	was_quoted(const char *str)
{
	int		in_quotes;
	char	quote_type;
	int		i;

	i = 0;
	in_quotes = 0;
	while (str && str[i])
	{
		if (!in_quotes && (str[i] == '\'' || str[i] == '"'))
		{
			in_quotes = 1;
			quote_type = str[i];
		}
		else if (in_quotes && str[i] == quote_type)
		{
			in_quotes = 0;
			return (1);
		}
		i++;
	}
	return (0);
}

int	has_var_in_dquotes(const char *str)
{
	int		i;
	t_state	state;

	i = 0;
	state = STATE_NORMAL;
	while (str[i])
	{
		update_quote_state(str[i], &state);
		if (str[i] == '$' && state == STATE_IN_DOUBLE_QUOTE)
			return (1);
		i++;
	}
	return (0);
}
#include "../minishell.h"

int	is_var_char(char c)
{
	return (ft_isalnum(c) || c == '_' || c == '?');
}

char	*extract_var_name(const char *str, int *pos)
{
	int	start;

	start = *pos;
	while (str[*pos] && is_var_char(str[*pos]))
		(*pos)++;
	return (ft_strndup(str + start, *pos - start));
}

char	*get_env_value(char *var_name, char **envp)
{
	int		i;
	size_t	var_len;
	char	*tmp;
	char	*interogation_var;

	i = 0;
	var_len = ft_strlen(var_name);
	if (ft_strncmp(var_name, "?", 1) == 0)
	{
		tmp = ft_itoa(g_last_exit_status);
		interogation_var = ft_strjoin(tmp, ft_strchr(var_name, '?') + 1);
		safe_free((void **)&tmp);
		return (interogation_var);
	}
	while (envp[i])
	{
		if (ft_strncmp(envp[i], var_name, var_len) == 0
			&& envp[i][var_len] == '=')
			return (ft_strdup(envp[i] + var_len + 1));
		i++;
	}
	return (NULL);
}

int	add_char_to_result(char **result, char c)
{
	char	*temp;
	char	buf[2];

	buf[0] = c;
	buf[1] = '\0';
	temp = *result;
	*result = ft_strjoin(*result, buf);
	if (temp)
		safe_free((void **)&temp);
	return (*result != NULL);
}
void	clean_empty_args(t_command *cmd)
{
	int	i;
	int	j;

	if (!cmd || !cmd->args)
		return ;
	i = 0;
	j = 0;
	while (i < cmd->args_count)
	{
		if (cmd->args[i] != NULL)
		{
			cmd->args[j] = cmd->args[i];
			if (i != j)
				cmd->args[i] = NULL;
			j++;
		}
		i++;
	}
	cmd->args_count = j;
}
#include "../minishell.h"

static int	process_variable(char **result, char *str, int *i, char **envp,
		int *is_empty_var)
{
	char	*var_name;
	char	*var_value;
	char	*temp;

	(*i)++;
	if (!str[*i] || ft_isspace(str[*i]) || str[*i] == '\"')
		return (add_char_to_result(result, '$'));
	var_name = extract_var_name(str, i);
	if (!var_name)
		return (0);
	var_value = get_env_value(var_name, envp);
	safe_free((void **)&var_name);
	if (!var_value)
	{
		*is_empty_var = 1;
		return (1);
	}
	temp = *result;
	*result = ft_strjoin(*result, var_value);
	if (temp)
		safe_free((void **)&temp);
	safe_free((void **)&var_value);
	return (*result != NULL);
}

static int	handle_expand_dollar(char **result, char *str, int *i, char **envp,
		int *is_empty_var)
{
	if (str[*i] == '$' && str[*i + 1])
	{
		if (!process_variable(result, str, i, envp, is_empty_var))
			return (0);
		return (1);
	}
	return (-1);
}

static int	handle_expand_char(char **result, char *str, int *i)
{
	if (!add_char_to_result(result, str[(*i)++]))
	{
		safe_free((void **)&(*result));
		return (0);
	}
	return (1);
}

char	*expand_variables(char *str, char **envp)
{
	int		i;
	char	*result;
	int		handle_ret;
	int		is_empty_var;
	int		has_quoted_vars;

	i = 0;
	is_empty_var = 0;
	has_quoted_vars = has_var_in_dquotes(str);
	result = ft_strdup("");
	if (!result)
		return (NULL);
	while (str[i])
	{
		handle_ret = handle_expand_dollar(&result, str, &i, envp,
				&is_empty_var);
		if (handle_ret == 0)
			return (NULL);
		else if (handle_ret == 1)
			continue ;
		if (!handle_expand_char(&result, str, &i))
			return (NULL);
	}
	if (is_empty_var && result && result[0] == '\0' && !has_quoted_vars
		&& !is_var_in_squotes(str))
		return (safe_free((void **)&result), NULL);
	return (result);
}


