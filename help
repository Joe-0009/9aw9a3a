#include "../minishell.h"

void	expand_command_args(t_command *cmd, char **envp)
{
	if (cmd && cmd->args)
		expand_args_loop(cmd, envp);
	if (cmd)
		expand_redirections_loop(cmd, envp);
	safe_doube_star_free(envp);
}
#include "../minishell.h"

int	is_var_char(char c)
{
	return (ft_isalnum(c) || c == '_' || c == '?');
}

char	*extract_var_name(const char *str, int *pos)
{
	int	start;

	start = *pos;
	while (str[*pos] && is_var_char(str[*pos]))
		(*pos)++;
	return (ft_strndup(str + start, *pos - start));
}

char	*get_env_value(char *var_name, char **envp)
{
	int		i;
	size_t	var_len;

	i = 0;
	var_len = ft_strlen(var_name);
	if (ft_strcmp(var_name, "?") == 0)
		return (ft_itoa(g_last_exit_status));
	while (envp[i])
	{
		if (ft_strncmp(envp[i], var_name, var_len) == 0
			&& envp[i][var_len] == '=')
			return (ft_strdup(envp[i] + var_len + 1));
		i++;
	}
	return (NULL);
}

int	add_char_to_result(char **result, char c)
{
	char	*temp;
	char	buf[2];

	buf[0] = c;
	buf[1] = '\0';
	temp = *result;
	*result = ft_strjoin(*result, buf);
	if (temp)
		free(temp);
	return (*result != NULL);
}

void	update_quote_state(char c, t_state *state)
{
	if (c == '"' && *state != STATE_IN_SINGLE_QUOTE)
	{
		if (*state == STATE_NORMAL)
			*state = STATE_IN_DOUBLE_QUOTE;
		else
			*state = STATE_NORMAL;
	}
	else if (c == '\'' && *state != STATE_IN_DOUBLE_QUOTE)
	{
		if (*state == STATE_NORMAL)
			*state = STATE_IN_SINGLE_QUOTE;
		else
			*state = STATE_NORMAL;
	}
}
#include "../minishell.h"

static int	process_variable(char **result, char *str, int *i, char **envp)
{
	char	*var_name;
	char	*var_value;
	char	*temp;

	(*i)++;
	if (!str[*i] || ft_isspace(str[*i]))
		return (add_char_to_result(result, '$'));
	var_name = extract_var_name(str, i);
	if (!var_name)
		return (0);
	var_value = get_env_value(var_name, envp);
	free(var_name);
	if (!var_value)
		return (1);
	temp = *result;
	*result = ft_strjoin(*result, var_value);
	if (temp)
		free(temp);
	free(var_value);
	return (*result != NULL);
}

static int	handle_expand_dollar(char **result, char *str, int *i, char **envp,
		t_state state)
{
	if (str[*i] == '$' && state != STATE_IN_SINGLE_QUOTE && str[*i + 1])
	{
		if (!process_variable(result, str, i, envp))
			return (0);
		return (1);
	}
	return (-1);
}

static int	handle_expand_char(char **result, char *str, int *i)
{
	if (!add_char_to_result(result, str[(*i)++]))
	{
		free(*result);
		return (0);
	}
	return (1);
}

char	*expand_variables(char *str, char **envp)
{
	int		i;
	t_state	state;
	char	*result;
	int		handle_ret;

	i = 0;
	state = STATE_NORMAL;
	result = ft_strdup("");
	if (!result)
		return (NULL);
	while (str[i])
	{
		update_quote_state(str[i], &state);
		handle_ret = handle_expand_dollar(&result, str, &i, envp, state);
		if (handle_ret == 0)
			return (NULL);
		else if (handle_ret == 1)
			continue ;
		if (!handle_expand_char(&result, str, &i))
			return (NULL);
	}
	return (result);
}
#include "../minishell.h"

int	count_split_words(char **split_words)
{
	int	count;

	count = 0;
	while (split_words[count])
		count++;
	return (count);
}

void	copy_and_replace_args(t_command *cmd, char **new_args,
		int pos, char **split_words)
{
	int	i;
	int	j;

	i = -1;
	while (++i < pos)
		new_args[i] = cmd->args[i];
	j = 0;
	while (split_words[j])
		new_args[i++] = ft_strdup(split_words[j++]);
	j = pos + 1;
	while (j < cmd->args_count)
		new_args[i++] = cmd->args[j++];
	free(cmd->args[pos]);
	free(cmd->args);
	cmd->args = new_args;
	cmd->args_count = i;
}

int	add_split_args_to_command(t_command *cmd, int pos,
		char **split_words)
{
	char	**new_args;
	int		word_count;
	
	word_count = count_split_words(split_words);
	if (word_count <= 1)
		return (ft_free_strs(split_words), 0);
	new_args = ft_calloc(cmd->args_count + word_count - 1, sizeof(char *));
	if (!new_args)
		return (ft_free_strs(split_words), -1);
	copy_and_replace_args(cmd, new_args, pos, split_words);
	ft_free_strs(split_words);
	return (word_count - 1);
}

void	expand_and_strip_arg(t_command *cmd, char **envp, int i)
{
	char	*expanded;
	char	*stripped;

	expanded = expand_variables(cmd->args[i], envp);
	if (expanded)
	{
		free(cmd->args[i]);
		cmd->args[i] = expanded;
	}
	stripped = strip_quotes(cmd->args[i]);
	if (stripped)
	{
		free(cmd->args[i]);
		cmd->args[i] = stripped;
	}
}

int	split_and_insert_args(t_command *cmd, int i, int is_export)
{
	char	**split_words;
	int		added;

	if (i > 0 && !is_export)
	{
		split_words = ft_split(cmd->args[i], ' ');
		if (split_words && split_words[0])
		{
			added = add_split_args_to_command(cmd, i, split_words);
			if (added > 0)
			{
				return (added);
			}
		}
	}
	return (0);
}#include "../minishell.h"

void	compact_args(t_command *cmd, int *i, int *j)
{
	if (cmd->args[*i] && cmd->args[*i][0] != '\0')
	{
		if (*i != *j)
		{
			cmd->args[*j] = cmd->args[*i];
			cmd->args[*i] = NULL;
		}
		(*j)++;
	}
	else if (cmd->args[*i])
	{
		free(cmd->args[*i]);
		cmd->args[*i] = NULL;
	}
}

void	expand_args_loop(t_command *cmd, char **envp)
{
	int	i;
	int	j;
	int	added;
	int	is_export;

	if (!cmd || !cmd->args || cmd->args_count <= 0)
		return ;
	i = 0;
	j = 0;
	added = 0;
	is_export = (cmd->args[0] && ft_strcmp(cmd->args[0], "export") == 0);
	while (i < cmd->args_count)
	{
		if (cmd->args[i])
		{
			expand_and_strip_arg(cmd, envp, i);
			added = split_and_insert_args(cmd, i, is_export);
			if (added > 0)
				continue ;
			compact_args(cmd, &i, &j);
		}
		i++;
	}
	cmd->args_count = j;
}

void	expand_redirections_loop(t_command *cmd, char **envp)
{
	t_redirections	*redir;
	char			*expanded;

	redir = cmd->redirections;
	while (redir)
	{
		if (redir->type != TOKEN_HEREDOC)
		{
			expanded = expand_variables(redir->file, envp);
			if (expanded)
			{
				free(redir->file);
				redir->file = expanded;
			}
		}
		redir = redir->next;
	}
}#include "../minishell.h"

int	is_builtin_command(char *cmd)
{
	char	*builtins[] = {"cd", "echo", "pwd", "export", "unset", "env",
			"exit", NULL};
	int		i;

	i = -1;
	while (builtins[++i])
	{
		if (ft_strcmp(builtins[i], cmd) == 0)
			return (1);
	}
	return (0);
}

int	execute_builtin(t_command *cmd, t_env **env_list)
{
	char	*command;

	command = cmd->args[0];
	if (ft_strcmp(command, "cd") == 0)
		return (builtin_cd(cmd, env_list));
	else if (ft_strcmp(command, "echo") == 0)
		return (builtin_echo(cmd));
	else if (ft_strcmp(command, "pwd") == 0)
		return (builtin_pwd(env_list));
	else if (ft_strcmp(command, "export") == 0)
		return (builtin_export(cmd, env_list));
	else if (ft_strcmp(command, "unset") == 0)
		return (builtin_unset(cmd, env_list));
	else if (ft_strcmp(command, "env") == 0)
		return (builtin_env(*env_list));
	else if (ft_strcmp(command, "exit") == 0)
		return (builtin_exit(cmd, env_list));
	return (1);
}

int	is_parent_builtin(char *cmd)
{
	return (ft_strcmp(cmd, "cd") == 0 || ft_strcmp(cmd, "export") == 0
		|| ft_strcmp(cmd, "unset") == 0 || ft_strcmp(cmd, "exit") == 0);
}

int	execute_single_parent_builtin(t_command *cmd_list, t_env **env_list)
{
	int	status;

	expand_command_args(cmd_list, env_list_to_envp(*env_list));
	status = execute_builtin(cmd_list, env_list);
	setup_signals();
	return (status);
}#include "../minishell.h"

void	handle_child_input(int prev_pipe_read)
{
	if (prev_pipe_read != -1)
	{
		if (dup2(prev_pipe_read, STDIN_FILENO) == -1)
		{
			perror("minishell: dup2 error on input");
			exit(1);
		}
		safe_close(&prev_pipe_read);
	}
}

void	handle_child_output(t_command *current, int pipe_fd[2])
{
	if (current->next)
	{
		safe_close(&pipe_fd[0]);
		if (dup2(pipe_fd[1], STDOUT_FILENO) == -1)
		{
			perror("minishell: dup2 error on output");
			exit(1);
		}
		safe_close(&pipe_fd[1]);
	}
}

void	child_process(t_command *current, int prev_pipe_read, int pipe_fd[2],
		t_env *env_list)
{
	set_sigint_default();
	signal(SIGQUIT, SIG_DFL);
	handle_child_input(prev_pipe_read);
	handle_child_output(current, pipe_fd);
	if (setup_redirections(current) == -1)
		exit(1);
	execute_single_command(current, env_list);
	ft_putstr_fd("minishell: command execution failed\n", 2);
	exit(127);
}

int	wait_for_children(void)
{
	pid_t	last_pid;
	int		status;
	int		last_status;

	status = 0;
	last_status = 0;
	while ((last_pid = waitpid(-1, &status, 0)) > 0)
	{
		if (WIFSIGNALED(status))
		{
			last_status = 128 + WTERMSIG(status);
			if (WTERMSIG(status) == SIGQUIT && g_last_exit_status != 131)
				write(STDERR_FILENO, "Quit (core dumped)\n", 19);
			if (WTERMSIG(status) == SIGINT)
				write(STDOUT_FILENO, "\n", 1);
		}
		else if (WIFEXITED(status))
		{
			last_status = WEXITSTATUS(status);
		}
	}
	return (last_status);
}

int	parent_process(int prev_pipe_read, int pipe_fd[2])
{
	if (prev_pipe_read != -1)
		close(prev_pipe_read);
	if (pipe_fd[1] != -1)
	{
		close(pipe_fd[1]);
		return (pipe_fd[0]);
	}
	if (pipe_fd[0] != -1)
		return (pipe_fd[0]);
	return (-1);
}#include "../minishell.h"

void	handle_builtin_command(t_command *current, t_env *env_list)
{
	execute_builtin(current, &env_list);
	exit(g_last_exit_status);
}

void	handle_external_command(t_command *current, t_env *env_list)
{
	char	*path;
	char	**envp;

	envp = env_list_to_envp(env_list);
	path = find_executable_path(current->args[0], envp);
	if (path)
	{
		if (execve(path, current->args, envp) == -1)
		{
			perror("minishell: execve");
			free(path);
			safe_doube_star_free(envp);
			exit(126);
		}
	}
	else
	{
		safe_doube_star_free(envp);
		ft_fprintf_fd(2, "minishell: %s: command not found\n",
			current->args[0]);
		exit(127);
	}
}

void	execute_single_command(t_command *current, t_env *env_list)
{
	if (current->args && current->args[0]
		&& is_builtin_command(current->args[0]))
		exit(execute_builtin(current, &env_list));
	else if (current->args && current->args[0])
		handle_external_command(current, env_list);
	exit(0);
}

int	setup_command_pipe(t_command *current, int *prev_pipe_read, int pipe_fd[2])
{
	if (current->next)
	{
		if (setup_pipe(pipe_fd) == -1)
		{
			safe_close(prev_pipe_read);
			return (0);
		}
	}
	else
	{
		pipe_fd[0] = -1;
		pipe_fd[1] = -1;
	}
	return (1);
}
#include "../minishell.h"

static int	setup_all_heredocs(t_command *cmd_list, char **envp)
{
	t_command		*current;
	t_redirections	*redir;
	int				result;

	current = cmd_list;
	while (current)
	{
		redir = current->redirections;
		while (redir)
		{
			if (redir->type == TOKEN_HEREDOC)
			{
				result = handle_heredoc_redir(redir, envp);
				if (result == 130)
					return (130);
				if (result == -1)
					return (-1);
			}
			redir = redir->next;
		}
		current = current->next;
	}
	return (0);
}

static int	init_and_setup_heredocs(t_command *cmd_list, t_env **env_list,
		int pipe_fd[2], int *prev_pipe_read)
{
	int	setup_result;
	char **envp;

	envp = env_list_to_envp(*env_list);
	setup_result = setup_all_heredocs(cmd_list, envp);
	if (setup_result == 130)
		return (safe_doube_star_free(envp), 130);
	if (setup_result == -1)
		return (safe_doube_star_free(envp), 1);
	pipe_fd[0] = -1;
	pipe_fd[1] = -1;
	*prev_pipe_read = -1;
	safe_doube_star_free(envp);
	return (0);
}

static void	execute_command_process(t_command *current, int *prev_pipe_read,
		int pipe_fd[2], t_env **env_list)
{
	pid_t	pid;

	expand_command_args(current, env_list_to_envp(*env_list));
	if (!setup_command_pipe(current, prev_pipe_read, pipe_fd))
		return ;
	pid = fork();
	if (pid == -1)
	{
		handle_fork_error(current, *prev_pipe_read, pipe_fd);
		return ;
	}
	if (pid == 0)
		child_process(current, *prev_pipe_read, pipe_fd, *env_list);
	*prev_pipe_read = parent_process(*prev_pipe_read, pipe_fd);
}

int	execute_command_list(t_command *cmd_list, t_env **env_list)
{
	int			pipe_fd[2];
	int			prev_pipe_read;
	int			status;
	t_command	*current;
	int			init_result;

	setup_exec_signals();
	if (cmd_list && cmd_list->next == NULL && cmd_list->args
		&& cmd_list->args[0] && is_parent_builtin(cmd_list->args[0]))
		return (execute_single_parent_builtin(cmd_list, env_list));
	
	init_result = init_and_setup_heredocs(cmd_list, env_list, pipe_fd,
			&prev_pipe_read);
	if (init_result != 0)
		return (init_result);
	
	current = cmd_list;
	while (current)
	{
		execute_command_process(current, &prev_pipe_read, pipe_fd, env_list);
		current = current->next;
	}
	status = wait_for_children();
	setup_signals();
	return (status);
}
#include "../minishell.h"

int	setup_pipe(int pipe_fd[2])
{
	if (pipe(pipe_fd) == -1)
	{
		perror("minishell: pipe creation failed");
		return (-1);
	}
	return (0);
}

int	handle_heredoc_redir(t_redirections *redir, char **envp)
{
	int	heredoc_fd;

	heredoc_fd = setup_heredoc(redir->file, envp);
	if (heredoc_fd == 130)
		return (130);
	if (heredoc_fd == -1)
		return (-1);
	redir->heredoc_fd = heredoc_fd;
	return (0);
}

void	handle_fork_error(t_command *current, int prev_pipe_read,
		int pipe_fd[2])
{
	perror("minishell: fork error");
	safe_close(&prev_pipe_read);
	if (current->next)
	{
		safe_close(&pipe_fd[0]);
		safe_close(&pipe_fd[1]);
	}
}#include "../minishell.h"

static int	is_delimiter_quoted(char *delimiter)
{
	size_t	i;
	size_t	len;
	int		in_quotes;
	char	quote_type;
	int		quoted;

	i = 0;
	in_quotes = 0;
	quoted = 0;
	len = ft_strlen(delimiter);
	while (i < len)
	{
		if ((delimiter[i] == '"' || delimiter[i] == '\''))
		{
			if (!in_quotes)
			{
				in_quotes = 1;
				quote_type = delimiter[i];
				i++;
			}
			else if (in_quotes && delimiter[i] == quote_type)
			{
				quoted = 1;
				in_quotes = 0;
				i++;
			}
			else
				i++;
		}
		else
			i++;
	}
	return (quoted);
}

static void	handle_heredoc_child_process(int pipe_fd[2], char *delimiter,
		char **envp)
{
	int		quoted;
	char	*line;
	char	*processed_delimiter;

	setup_heredoc_signals();
	safe_close(&pipe_fd[0]);
	quoted = is_delimiter_quoted(delimiter);
	processed_delimiter = strip_quotes(delimiter);
	if (!processed_delimiter)
		exit(1);
	while (1)
	{
		line = readline("> ");
		if (!line)
		{
			if (g_last_exit_status == 130)
				break ;
			ft_putstr_fd("minishell: warning: heredoc delimited by end-of-file\n", 2);
			break ;
		}
		if (ft_strcmp(line, processed_delimiter) == 0)
		{
			safe_free((void **)&line);
			break ;
		}
		if (!quoted)
			ft_putstr_fd(expand_variables(line, envp), pipe_fd[1]);
		else
			ft_putstr_fd(line, pipe_fd[1]);
		ft_putchar_fd('\n', pipe_fd[1]);
		safe_free((void **)&line);
	}
	safe_free((void **)&processed_delimiter);
	safe_close(&pipe_fd[1]);
	exit(0);
}

int	setup_heredoc(char *delimiter, char **envp)
{
	int		pipe_fd[2];
	pid_t	pid;
	int		status;

	if (pipe(pipe_fd) == -1)
		return (ft_putstr_fd("minishell: heredoc pipe error\n", 2), -1);
	pid = fork();
	if (pid == -1)
	{
		safe_close(&pipe_fd[0]);
		safe_close(&pipe_fd[1]);
		return (ft_putstr_fd("minishell: heredoc fork error\n", 2), -1);
	}
	if (pid == 0)
		handle_heredoc_child_process(pipe_fd, delimiter, envp);
	safe_close(&pipe_fd[1]);
	waitpid(pid, &status, 0);
	setup_signals();
	if (WIFSIGNALED(status) && WTERMSIG(status) == SIGINT)
	{
		safe_close(&pipe_fd[0]);
		g_last_exit_status = 130;
		return (130);
	}
	return (pipe_fd[0]);
}
#include "../minishell.h"

static int	handle_cd_errors(char *dir, char *old_pwd)
{
	if (old_pwd)
		free(old_pwd);
	if (!dir)
		return (ft_putstr_fd("minishell: cd: HOME not set\n", 2), 1);
	else
		return (ft_fprintf_fd(2, "minishell: cd: %s: %s\n", dir,
				strerror(errno)), 1);
}

static int	update_pwd_vars(t_env **env, char *old_pwd)
{
	char	*new_pwd;

	new_pwd = getcwd(NULL, 0);
	if (!new_pwd)
		return (ft_fprintf_fd(2,
				"minishell: cd: error retrieving current directory: getcwd: cannot access parent directories: No such file or directory\n"), 1
            );
	if (new_pwd)
	{
		add_or_update_env(env, "PWD", new_pwd);
		if (old_pwd)
			add_or_update_env(env, "OLDPWD", old_pwd);
		free(new_pwd);
	}
	if (old_pwd)
		free(old_pwd);
    return (1);
}

int	builtin_cd(t_command *cmd, t_env **env)
{
	char	*old_pwd;
	char	*dir;
	int		ret;

	old_pwd = getcwd(NULL, 0);
	if (cmd->args_count > 2)
	{
		if (old_pwd)
			free(old_pwd);
		return (ft_putstr_fd("minishell: cd: too many arguments\n", 2), 1);
	}
	dir = (cmd->args_count == 1) ? find_env_node(*env,
			"HOME")->value : cmd->args[1];
	if (cmd->args_count == 1 && !dir)
		return (handle_cd_errors(NULL, old_pwd));
	ret = chdir(dir);
	if (ret != 0)
		return (handle_cd_errors(dir, old_pwd));
	update_pwd_vars(env, old_pwd);
	return (0);
}

static int	print_pwd_from_env(t_env **env)
{
	t_env	*pwd_node;

	pwd_node = find_env_node(*env, "PWD");
	if (pwd_node && pwd_node->value)
	{
		ft_fprintf_fd(1, "%s\n", pwd_node->value);
		return (0);
	}
	return (ft_fprintf_fd(2,
			"minishell: pwd: error retrieving current directory\n"), 1);
}

int	builtin_pwd(t_env **env)
{
	char	*cwd;

	cwd = getcwd(NULL, 0);
	if (cwd)
	{
		ft_fprintf_fd(1, "%s\n", cwd);
		free(cwd);
		return (0);
	}
	return (print_pwd_from_env(env));
}
#include "../minishell.h"

static int	is_valid_n_flag(char *arg)
{
	int	i;

	if (arg[0] != '-' || arg[1] != 'n')
		return (0);
	i = 2;
	while (arg[i])
	{
		if (arg[i] != 'n')
			return (0);
		i++;
	}
	return (1);
}

int	builtin_echo(t_command *cmd)
{
	int	i;
	int	print_newline;

	i = 1;
	print_newline = 1;
	while (i < cmd->args_count && is_valid_n_flag(cmd->args[i]))
	{
		print_newline = 0;
		i++;
	}
	while (i < cmd->args_count)
	{
		printf("%s", cmd->args[i]);
		if (i < cmd->args_count - 1)
			printf(" ");
		i++;
	}
	if (print_newline)
		printf("\n");
	return (0);
}
#include "../minishell.h"

int	builtin_env(t_env *env_list)
{
	t_env	*current;

	current = env_list;
	while (current)
	{
		if (current->value)
		{
			ft_putstr_fd(current->key, 1);
			ft_putchar_fd('=', 1);
			ft_putstr_fd(current->value, 1);
			ft_putchar_fd('\n', 1);
		}
		current = current->next;
	}
	return (0);
}#include "../minishell.h"

int	is_valid_identifier(char *str)
{
	int	i;

	if (!str || (!ft_isalpha(str[0]) && str[0] != '_'))
		return (0);
	i = 1;
	while (str[i])
	{
		if (!ft_isalnum(str[i]) && str[i] != '_')
			return (0);
		i++;
	}
	return (1);
}

t_env	*find_env_node(t_env *env_list, const char *key)
{
	while (env_list)
	{
		if (ft_strcmp(env_list->key, key) == 0)
			return (env_list);
		env_list = env_list->next;
	}
	return (NULL);
}

t_env	*add_or_update_env(t_env **env_list, const char *key, const char *value)
{
	t_env	*node;

	node = find_env_node(*env_list, key);
	if (node)
	{
		if (node->value)
			free(node->value);
		if (value != NULL)
			node->value = ft_strdup(value);
		else
			node->value = NULL;
		return (node);
	}
	node = (t_env *)malloc(sizeof(t_env));
	if (!node)
		return (NULL);
	node->key = ft_strdup(key);
	if (value != NULL)
		node->value = ft_strdup(value);
	else
		node->value = NULL;
	node->next = *env_list;
	*env_list = node;
	return (node);
}

t_env	*envp_to_env_list(char **envp)
{
	t_env	*env_list;
	char	*equal_sign;
	char	*key;
	char	*value;
	int		i;

	env_list = NULL;
	i = 0;
	while (envp[i])
	{
		equal_sign = ft_strchr(envp[i], '=');
		if (equal_sign)
		{
			key = ft_substr(envp[i], 0, equal_sign - envp[i]);
			value = ft_strdup(equal_sign + 1);
			add_or_update_env(&env_list, key, value);
			free(key);
			free(value);
		}
		i++;
	}
	return (env_list);
}

static int	count_env_entries(t_env *env_list)
{
	t_env	*cur;
	int		size;

	size = 0;
	cur = env_list;
	while (cur)
	{
		if (cur->key)
			size++;
		cur = cur->next;
	}
	return (size);
}

static char	*create_env_string(char *key, char *value)
{
	char	*result;
	char	*temp;

	result = ft_strdup(key);
	if (!result)
		return (NULL);
	if (value)
	{
		temp = result;
		result = ft_strjoin(result, "=");
		free(temp);
		if (!result)
			return (NULL);
		temp = result;
		result = ft_strjoin(result, value);
		free(temp);
	}
	return (result);
}

char	**env_list_to_envp(t_env *env_list)
{
	t_env	*cur;
	char	**envp;
	int		size;
	int		i;

	size = count_env_entries(env_list);
	envp = (char **)ft_calloc(size + 1, sizeof(char *));
	if (!envp)
		return (NULL);
	cur = env_list;
	i = 0;
	while (cur)
	{
		if (cur->key)
		{
			envp[i] = create_env_string(cur->key, cur->value);
			if (!envp[i])
				return (safe_doube_star_free(envp), NULL);
			i++;
		}
		cur = cur->next;
	}
	return (envp);
}
#include "../minishell.h"

static int	process_exit_arg(char *arg)
{
	int	exit_status;

	if (!is_number(arg))
	{
		ft_fprintf_fd(2, "minishell: exit: %s: numeric argument required\n", arg);
		return (2);
	}
	exit_status = ft_atoi(arg);
	return (exit_status);
}

int	builtin_exit(t_command *cmd, t_env **env_list)
{
	int	exit_status;

	printf("exit\n");
	if (cmd->args_count > 2)
	{
		ft_putstr_fd("minishell: exit: too many arguments\n", 2);
		return (1);
	}
	if (cmd->args_count > 1)
		exit_status = process_exit_arg(cmd->args[1]);
	else
		exit_status = 0;
	free_command_list(cmd);
	free_env_list(*env_list);
	clear_history();
	exit(exit_status);
}
#include "../minishell.h"

int	builtin_export(t_command *cmd, t_env **env_list)
{
	int	i;

	if (!cmd->args[1])
	{
		print_export_list(*env_list);
		return (0);
	}
	i = 1;
	while (cmd->args[i])
	{
		export_one_arg(cmd->args[i], env_list);
		i++;
	}
	return (0);
}

void	print_export_list(t_env *env_list)
{
	t_env	*cur;

	cur = env_list;
	while (cur)
	{
		if (cur->key)
		{
			if (cur->value)
			{
				ft_putstr_fd("declare -x ", 1);
				ft_putstr_fd(cur->key, 1);
				ft_putstr_fd("=\"", 1);
				ft_putstr_fd(cur->value, 1);
				ft_putstr_fd("\"\n", 1);
			}
			else
			{
				ft_putstr_fd("declare -x ", 1);
				ft_putstr_fd(cur->key, 1);
				ft_putchar_fd('\n', 1);
			}
		}
		cur = cur->next;
	}
}

static void	handle_append_mode(char **value, char *key, t_env **env_list)
{
	t_env	*existing;
	char	*new_value;

	existing = find_env_node(*env_list, key);
	if (existing && existing->value && *value)
	{
		new_value = ft_strjoin(existing->value, *value);
		*value = new_value;
	}
}

static void	handle_error(char *key, char **value)
{
	ft_putstr_fd("minishell: export: `", 2);
	ft_putstr_fd(key, 2);
	ft_putstr_fd("': not a valid identifier\n", 2);
	safe_free((void **)&key);
	if (*value)
		safe_free((void **)value);
}

static void	extract_key_value(char *arg, char **key, char **value,
		int *append_mode)
{
	char	*equal_sign;

	*append_mode = 0;
	equal_sign = ft_strchr(arg, '=');
	if (equal_sign)
	{
		if (equal_sign > arg && *(equal_sign - 1) == '+')
		{
			*append_mode = 1;
			*key = ft_substr(arg, 0, equal_sign - arg - 1);
		}
		else
			*key = ft_substr(arg, 0, equal_sign - arg);
		*value = strip_quotes(equal_sign + 1);
	}
	else
	{
		*key = ft_strdup(arg);
		*value = NULL;
	}
}

void	export_one_arg(char *arg, t_env **env_list)
{
	char	*key;
	char	*value;
	int		append_mode;

	extract_key_value(arg, &key, &value, &append_mode);
	if (!is_valid_identifier(key))
	{
		handle_error(key, &value);
		return ;
	}
	if (append_mode)
		handle_append_mode(&value, key, env_list);
	add_or_update_env(env_list, key, value);
	safe_free((void **)&key);
	if (value)
		safe_free((void **)&value);
}
#include "../minishell.h"

int	builtin_unset(t_command *cmd, t_env **env_list)
{
	int i;

	i = 1;
	while (cmd->args[i])
	{
		unset_one_arg(cmd->args[i], env_list);
		i++;
	}
	return (0);
}#include "../minishell.h"

static void	free_env_node(t_env *node)
{
	free(node->key);
	if (node->value)
		free(node->value);
	free(node);
}

void	unset_one_arg(char *arg, t_env **env_list)
{
	t_env	*prev;
	t_env	*cur;

	if (!is_valid_identifier(arg))
	{
		printf("minishell: unset: `%s': not a valid identifier\n", arg);
		return ;
	}
	prev = NULL;
	cur = *env_list;
	while (cur)
	{
		if (ft_strcmp(cur->key, arg) == 0)
		{
			if (prev)
				prev->next = cur->next;
			else
				*env_list = cur->next;
			free_env_node(cur);
			break ;
		}
		prev = cur;
		cur = cur->next;
	}
}
